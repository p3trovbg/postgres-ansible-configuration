#!/usr/bin/env bash
set -euo pipefail

PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

###############################################################################
# postgres_restore.sh
#
# Restores Postgres data from encrypted backups produced by the backup script.
#
# Features:
#   - Fetches backup dir from remote storage server via rsync
#   - Decrypts GPG-encrypted files (.gpg)
#   - Optionally restores global objects (roles, privileges) from globals.dump.gpg
#   - Restores either:
#       * a specific database (-d DB_NAME)
#       * all databases in the backup (--all)
#
# Usage:
#   postgres-restore.sh -b <BACKUP_DATE> -d <DB_NAME> [--with-globals]
#   postgres-restore.sh -b <BACKUP_DATE> --all [--with-globals]
#
# Examples:
#   # Restore ONLY main_db from backup 2025-11-24_12-00-00 (no globals)
#   postgres-restore.sh -b 2025-11-24_12-00-00 -d main_db
#
#   # Restore ALL databases + global roles
#   postgres-restore.sh -b 2025-11-24_12-00-00 --all --with-globals
#
###############################################################################

# ------------ Static configuration from Ansible (templated) ------------------

# Remote backup server information (where backups are stored)
REMOTE_USER="{{ backup_server_user }}"              # e.g. backupuser
REMOTE_HOST="{{ backup_server_host }}"              # e.g. backup.example.com
REMOTE_DIR="{{ backup_server_remote_dir }}"         # e.g. /backups/postgres
REMOTE_PORT="{{ backup_server_ssh_port }}"

# SSH key to access remote backup server
SSH_KEY="{{ backup_rsync_private_key_path }}"       # e.g. /root/.ssh/backup_rsync

# Local working directory on the Postgres server where we stage restores
LOCAL_RESTORE_ROOT="{{ postgres_restore_work_dir | default('/var/tmp/postgres-restore') }}"

# Postgres container + user
POSTGRES_CONTAINER="{{ postgres_container_name }}"  # e.g. postgres-db-ubuntu
POSTGRES_USER="{{ postgres_user }}"                 # e.g. postgres

# GPG passphrase used to encrypt backups (same as backup script)
ENCRYPT_PASSPHRASE="{{ backup_encryption_passphrase }}"

###############################################################################
# Argument parsing
###############################################################################

usage() {
  cat <<EOF
Usage:
  $0 -b <BACKUP_DATE> [-d <DB_NAME> | --all] [--with-globals]

Options:
  -b <BACKUP_DATE>   Backup timestamp (directory name), e.g. 2025-11-24_12-00-00
  -d <DB_NAME>       Restore only this database
  --all              Restore ALL databases found in the backup directory
  --with-globals     Also restore global objects (roles, privileges) from globals.dump.gpg
  -h, --help         Show this help message

Notes:
  - BACKUP_DATE should match the directory name created by the backup script.
  - Databases are expected to be stored as <db>.dump.gpg in the backup dir.
  - This script will DROP and recreate the target database(s).
EOF
}

BACKUP_DATE=""
DB_NAME=""
RESTORE_ALL=0
WITH_GLOBALS=0

# Parse short options (-b, -d, -h) and long options (--all, --with-globals)
while [[ $# -gt 0 ]]; do
  case "$1" in
    -b)
      BACKUP_DATE="$2"
      shift 2
      ;;
    -d)
      DB_NAME="$2"
      shift 2
      ;;
    --all)
      RESTORE_ALL=1
      shift 1
      ;;
    --with-globals)
      WITH_GLOBALS=1
      shift 1
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown argument: $1"
      usage
      exit 1
      ;;
  esac
done

if [[ -z "$BACKUP_DATE" ]]; then
  echo "ERROR: -b <BACKUP_DATE> is required."
  usage
  exit 1
fi

if [[ $RESTORE_ALL -eq 0 && -z "$DB_NAME" ]]; then
  echo "ERROR: Either -d <DB_NAME> or --all must be specified."
  usage
  exit 1
fi

if [[ $RESTORE_ALL -eq 1 && -n "$DB_NAME" ]]; then
  echo "ERROR: You cannot use -d and --all together."
  usage
  exit 1
fi

###############################################################################
# Helper functions
###############################################################################

log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

decrypt_file() {
  local enc_file="$1"
  local out_file="$2"

  log "Decrypting ${enc_file} -> ${out_file}"
  printf '%s' "$ENCRYPT_PASSPHRASE" | gpg \
    --batch --yes \
    --passphrase-fd 0 \
    -o "$out_file" \
    -d "$enc_file"
}

###############################################################################
# STEP 1: Fetch backup directory from remote storage server
###############################################################################

LOCAL_BACKUP_DIR="${LOCAL_RESTORE_ROOT}/${BACKUP_DATE}"

mkdir -p "$LOCAL_BACKUP_DIR"

log "Fetching backup ${BACKUP_DATE} from ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DIR}/${BACKUP_DATE}/"
rsync -az -e "ssh -i ${SSH_KEY} -p ${REMOTE_PORT} -o StrictHostKeyChecking=no" \
  "${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DIR}/${BACKUP_DATE}/" \
  "${LOCAL_BACKUP_DIR}/"

log "Backup fetched into ${LOCAL_BACKUP_DIR}"

###############################################################################
# STEP 2: Optionally restore global objects (roles, privileges)
###############################################################################

if [[ $WITH_GLOBALS -eq 1 ]]; then
  GLOBALS_ENC="${LOCAL_BACKUP_DIR}/globals.dump.gpg"
  if [[ -f "$GLOBALS_ENC" ]]; then
    GLOBALS_SQL="${LOCAL_BACKUP_DIR}/globals.dump"
    decrypt_file "$GLOBALS_ENC" "$GLOBALS_SQL"

    log "Restoring global objects (roles, privileges) from globals.dump"
    cat "$GLOBALS_SQL" | docker exec -i "$POSTGRES_CONTAINER" psql -U "$POSTGRES_USER"

    # Optionally remove plaintext after restore
    rm -f "$GLOBALS_SQL"
  else
    log "No globals.dump.gpg found in ${LOCAL_BACKUP_DIR}, skipping global restore."
  fi
else
  log "Skipping global objects restore (no --with-globals flag)."
fi

###############################################################################
# STEP 3: Determine which databases to restore
###############################################################################

declare -a DBS_TO_RESTORE=()

if [[ $RESTORE_ALL -eq 1 ]]; then
  # Take all *.dump.gpg files except globals.dump.gpg
  while IFS= read -r -d '' file; do
    base="$(basename "$file")"
    # Expect format: <db>.dump.gpg
    db="${base%.dump.gpg}"
    if [[ "$db" != "globals.dump" ]]; then
      DBS_TO_RESTORE+=("$db")
    fi
  done < <(find "$LOCAL_BACKUP_DIR" -maxdepth 1 -type f -name "*.dump.gpg" -print0)

  if [[ ${#DBS_TO_RESTORE[@]} -eq 0 ]]; then
    log "No *.dump.gpg database files found in ${LOCAL_BACKUP_DIR}"
    exit 1
  fi
else
  # Single DB restore
  DBS_TO_RESTORE+=("$DB_NAME")
fi

log "Databases to restore: ${DBS_TO_RESTORE[*]}"

###############################################################################
# STEP 4: Restore each database
#
# For each DB:
#   - Decrypt <db>.dump.gpg to <db>.dump
#   - DROP DATABASE IF EXISTS
#   - CREATE DATABASE
#   - Upload dump into container and run pg_restore
###############################################################################

for DB in "${DBS_TO_RESTORE[@]}"; do
  ENC_DUMP="${LOCAL_BACKUP_DIR}/${DB}.dump.gpg"
  PLAIN_DUMP="${LOCAL_BACKUP_DIR}/${DB}.dump"

  if [[ ! -f "$ENC_DUMP" ]]; then
    log "ERROR: Encrypted dump not found for database ${DB}: ${ENC_DUMP}"
    exit 1
  fi

  log "Decrypting dump for database ${DB}"
  decrypt_file "$ENC_DUMP" "$PLAIN_DUMP"

  log "Dropping database ${DB} (if exists)"
  docker exec "$POSTGRES_CONTAINER" psql -U "$POSTGRES_USER" -c "DROP DATABASE IF EXISTS \"$DB\";"

  log "Creating database ${DB}"
  docker exec "$POSTGRES_CONTAINER" psql -U "$POSTGRES_USER" -c "CREATE DATABASE \"$DB\";"

  # Copy dump file into container
  CONTAINER_DUMP_PATH="/tmp/${DB}.dump"

  log "Copying dump into container: ${CONTAINER_DUMP_PATH}"
  docker cp "$PLAIN_DUMP" "${POSTGRES_CONTAINER}:${CONTAINER_DUMP_PATH}"

  log "Restoring database ${DB} with pg_restore (custom format)"
  docker exec "$POSTGRES_CONTAINER" pg_restore \
    -U "$POSTGRES_USER" \
    -d "$DB" \
    "${CONTAINER_DUMP_PATH}"

  log "Cleaning up dump file inside container"
  docker exec "$POSTGRES_CONTAINER" rm -f "${CONTAINER_DUMP_PATH}"

  # Remove plaintext dump on host
  rm -f "$PLAIN_DUMP"

  log "Database ${DB} restore completed."
done

log "All requested databases restored successfully."
